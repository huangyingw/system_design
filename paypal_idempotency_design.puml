@startuml PayPal Idempotency Design
' ==================== Metadata ====================
' @category: distributed-systems
' @tags: #paypal-core, #idempotency, #payment-processing, #distributed-systems, #redis, #postgresql
' @application: PayPal
' @tech-stack: Redis, PostgreSQL, Kafka
' @pattern: Idempotency, State Machine
' @description: PayPal支付系统幂等性设计 - 防止重复扣款的核心机制
' @interview-focus: HIGH - PayPal必考的系统设计场景
' ==================================================

!include common_style.puml

title PayPal支付幂等性设计 - 防止重复扣款

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

actor "Client\n(用户/商户)" as Client
participant "API Gateway" as Gateway #LightBlue
participant "Idempotency\nService" as IdemService #Gold
database "Redis\n(幂等性缓存)" as Redis #Red
participant "Payment\nOrchestrator" as PaymentOrch #LightGreen
participant "Payment\nProcessor" as PaymentProc #LightGreen
database "PostgreSQL\n(交易数据库)" as DB #SkyBlue
queue "Kafka\n(事件流)" as Kafka #Orange

== 场景1: 首次支付请求（正常流程） ==

Client -> Gateway: POST /payments\n**Header**: Idempotency-Key: uuid-123-abc\n**Body**: {amount: 100, currency: USD}
note right of Client
  客户端生成UUID作为幂等性键
  每个支付请求必须带唯一ID
  格式: UUID v4
end note

Gateway -> IdemService: 1. 检查幂等性键
activate IdemService

IdemService -> Redis: GET idempotency:uuid-123-abc
Redis --> IdemService: Key不存在 (nil)

IdemService -> Redis: SET idempotency:uuid-123-abc\nvalue: {"status":"PROCESSING"}\nEXPIRE: 86400 (24小时)
note right of Redis
  **关键设计点**:
  1. 立即设置状态为PROCESSING
  2. 设置24小时过期时间
  3. 使用SET NX确保原子性
end note

IdemService -> PaymentOrch: 2. 转发支付请求
deactivate IdemService

activate PaymentOrch
PaymentOrch -> PaymentProc: 3. 处理支付

activate PaymentProc
PaymentProc -> DB: BEGIN TRANSACTION
PaymentProc -> DB: 4. INSERT INTO transactions\n(txn_id, idempotency_key,\namount, status, created_at)
PaymentProc -> DB: 5. INSERT INTO idempotency_keys\n(key, status, result, expires_at)\nON CONFLICT DO NOTHING
note right of DB
  **数据库双保险**:
  1. transactions表记录交易
  2. idempotency_keys表持久化
  3. UNIQUE约束防止重复
end note

PaymentProc -> DB: 6. UPDATE accounts\nSET balance = balance - 100\nWHERE user_id = xxx\nAND balance >= 100
note right of PaymentProc
  **悲观锁**:
  SELECT FOR UPDATE
  确保余额不会超扣
end note

PaymentProc -> DB: COMMIT
PaymentProc --> PaymentOrch: ✅ 支付成功\n{txn_id: "txn-456", status: "SUCCESS"}
deactivate PaymentProc

PaymentOrch -> IdemService: 7. 更新幂等性状态
activate IdemService
IdemService -> Redis: SET idempotency:uuid-123-abc\nvalue: {"status":"SUCCESS",\n"txn_id":"txn-456","amount":100}\nEXPIRE: 86400
IdemService -> Kafka: 发送PaymentSuccessEvent
deactivate IdemService

PaymentOrch --> Gateway: 200 OK\n{txn_id: "txn-456", status: "SUCCESS"}
deactivate PaymentOrch
Gateway --> Client: ✅ 支付成功

== 场景2: 网络超时重试（幂等性生效） ==

Client -> Gateway: POST /payments\n**Header**: Idempotency-Key: uuid-123-abc\n**Body**: {amount: 100, currency: USD}
note right of Client
  客户端使用相同的幂等性键重试
  可能原因:
  - 网络超时
  - 客户端崩溃后重启
  - 用户重复点击
end note

Gateway -> IdemService: 检查幂等性键
activate IdemService

IdemService -> Redis: GET idempotency:uuid-123-abc
Redis --> IdemService: **找到缓存**\n{"status":"SUCCESS",\n"txn_id":"txn-456","amount":100}

note right of IdemService
  **幂等性生效**:
  1. 检测到重复请求
  2. 返回缓存的结果
  3. 不再执行支付逻辑
  4. 保证HTTP响应一致性
end note

IdemService --> Gateway: 200 OK (缓存结果)\n{txn_id: "txn-456", status: "SUCCESS"}
deactivate IdemService
Gateway --> Client: ✅ 支付已处理（相同结果）

note right of Client
  客户端收到相同的响应
  txn_id相同，确认为同一笔交易
end note

== 场景3: 并发请求（防止竞态条件） ==

Client -> Gateway: POST /payments (请求A)\nIdempotency-Key: uuid-789-xyz
Client -> Gateway: POST /payments (请求B)\nIdempotency-Key: uuid-789-xyz

note right of Client
  **极端场景**:
  用户快速双击支付按钮
  两个请求几乎同时到达
end note

Gateway -> IdemService: 请求A: 检查幂等性键
Gateway -> IdemService: 请求B: 检查幂等性键

activate IdemService
IdemService -> Redis: 请求A: SET NX idempotency:uuid-789-xyz\nvalue: PROCESSING
Redis --> IdemService: 请求A: ✅ OK (设置成功)

IdemService -> Redis: 请求B: SET NX idempotency:uuid-789-xyz\nvalue: PROCESSING
Redis --> IdemService: 请求B: ❌ nil (键已存在，设置失败)

note right of Redis
  **Redis原子性操作**:
  SET NX (SET if Not eXists)
  只有一个请求能成功设置
  其他请求立即失败或等待
end note

IdemService -> IdemService: 请求B进入轮询等待
note right of IdemService
  **等待策略**:
  1. 轮询检查状态(每100ms)
  2. 最多等待5秒
  3. 超时返回409 Conflict
end note

IdemService -> PaymentOrch: 请求A: 继续处理支付
deactivate IdemService

' ... 支付处理流程 ...

IdemService -> Redis: 请求A完成: SET status=SUCCESS
IdemService -> IdemService: 请求B检测到SUCCESS状态
IdemService --> Gateway: 请求A: 200 OK
IdemService --> Gateway: 请求B: 200 OK (相同结果)

== 场景4: 支付失败后重试 ==

Client -> Gateway: POST /payments\nIdempotency-Key: uuid-999-fail
Gateway -> IdemService: 检查幂等性键
IdemService -> Redis: Key不存在，设置PROCESSING
IdemService -> PaymentOrch: 处理支付

PaymentOrch -> PaymentProc: 执行支付
PaymentProc -> DB: 检查余额
PaymentProc --> PaymentOrch: ❌ 余额不足

PaymentOrch -> IdemService: 更新状态为FAILED
IdemService -> Redis: SET idempotency:uuid-999-fail\nvalue: {"status":"FAILED",\n"error":"Insufficient balance"}\nEXPIRE: 3600 (1小时)

note right of Redis
  **失败场景处理**:
  1. 失败结果也缓存
  2. 过期时间更短(1小时)
  3. 允许用户充值后重试
  4. 但1小时内不允许重复尝试
end note

IdemService --> Gateway: 400 Bad Request\n{status: "FAILED", error: "Insufficient balance"}
Gateway --> Client: ❌ 支付失败

Client -> Client: 用户充值

Client -> Gateway: POST /payments\nIdempotency-Key: uuid-999-fail (1小时内重试)
Gateway -> IdemService: 检查幂等性键
IdemService -> Redis: GET idempotency:uuid-999-fail
Redis --> IdemService: {"status":"FAILED"...}
IdemService --> Gateway: 400 Bad Request (返回缓存的失败)
Gateway --> Client: ❌ 仍然是失败（幂等性）

note right of Client
  **业务逻辑**:
  1小时后过期，用户可以重新尝试
  或者使用新的幂等性键
end note

== 场景5: Redis缓存失效，数据库兜底 ==

Client -> Gateway: POST /payments\nIdempotency-Key: uuid-123-abc (Redis已过期)

Gateway -> IdemService: 检查幂等性键
IdemService -> Redis: GET idempotency:uuid-123-abc
Redis --> IdemService: Key不存在 (已过期)

IdemService -> DB: **兜底检查**\nSELECT * FROM idempotency_keys\nWHERE key = 'uuid-123-abc'\nAND expires_at > NOW()

note right of DB
  **双层防护**:
  1. Redis作为第一层（快速）
  2. PostgreSQL作为第二层（可靠）
  3. 数据库保留更长时间（7-30天）
end note

DB --> IdemService: 找到记录\n{status: SUCCESS, txn_id: txn-456}

IdemService -> Redis: **回填缓存**\nSET idempotency:uuid-123-abc\nvalue: {status:SUCCESS, txn_id:txn-456}\nEXPIRE: 86400

IdemService --> Gateway: 200 OK (从数据库恢复)
Gateway --> Client: ✅ 支付已处理

@enduml
