@startuml HDFS Data Model
' ==================== Metadata ====================
' @category: database
' @tags: #database, #redis
' @application: General
' @tech-stack: Redis
' @pattern: Architecture
' @description: Distributed File System Database Schema With Namenode And Datanode Components
' ==================================================

!define TABLE(name,desc) class name as "desc" << (T,#FFAAAA) >>
!define PK(x) <u>x</u>
!define FK(x) <i>x</i>
skinparam backgroundColor #FEFEFE
skinparam handwritten false
skinparam monochrome false
skinparam lineType ortho
skinparam shadowing false
skinparam class {
    BackgroundColor #E0F2F1
    ArrowColor #4A4A4A
    BorderColor #1A237E
    FontName Arial
    FontSize 10
}
skinparam note {
    BackgroundColor #FFF9C4
    BorderColor #FBC02D
}
' NameNode Components
rectangle "NameNode" as NameNode #E8F5E9 {
    TABLE(FileMetadata, "File Metadata") {
        PK(file_path): STRING
        file_name: STRING
        file_size: LONG
        owner: STRING
        permissions: STRING
        created_at: LONG
        updated_at: LONG
        is_directory: BOOLEAN
        replication_factor: SHORT
    }
    TABLE(BlockMetadata, "Block Metadata") {
        PK(block_id): LONG
        FK(file_path): STRING
        block_size: LONG
        block_locations: LIST<DataNodeID>
        generation_stamp: LONG
    }
    TABLE(DataNodeInfo, "DataNode Info") {
        PK(node_id): STRING
        hostname: STRING
        ip_address: STRING
        total_space: LONG
        used_space: LONG
        last_heartbeat: LONG
        status: STRING
        rack_id: STRING
    }
}

note right of NameNode
    NameNode is the core of HDFS, responsible for:
    1. Managing the file system namespace
    2. Maintaining metadata for files and directories
    3. Managing the mapping of data blocks to DataNodes
    4. Handling client read/write requests
end note

' NameNode Persistent Storage
rectangle "NameNode Persistent Storage" as NameNodeStorage #FFF3E0 {
    TABLE(EditLog, "Edit Log") {
        PK(transaction_id): LONG
        operation_type: STRING
        operation_details: STRING
        timestamp: LONG
    }
    TABLE(FSImage, "FSImage") {
        PK(checkpoint_txid): LONG
        file_system_metadata: BYTE[]
        timestamp: LONG
    }
}

note bottom of NameNodeStorage
    Persistent storage ensures system recoverability:
    - EditLog records all file system operations
    - FSImage is a snapshot of file system metadata
    Periodically merge EditLog into FSImage for efficiency
end note

' DataNode Components
rectangle "DataNode" as DataNode #E1F5FE {
    TABLE(DataBlocks, "Data Blocks") {
        PK(block_id): LONG
        data: BYTE[]
        checksum: BYTE[]
    }
    TABLE(BlockReport, "Block Report") {
        FK(node_id): STRING
        FK(block_id): LONG
        block_length: LONG
        generation_stamp: LONG
    }
}

note left of DataNode
    DataNode is responsible for:
    1. Storing actual data blocks
    2. Handling read/write requests for data blocks
    3. Periodically reporting block status to NameNode
    4. Executing block replication and deletion
end note

' Cache Layer
rectangle "Cache Layer" as CacheLayer #F3E5F5 {
    TABLE(RedisCache, "Redis Cache Cluster") {
        key: STRING
        value: STRING
        expiration: INT
    }
}

note bottom of RedisCache
    Keys:
    file_metadata:{file_path}
    block_locations:{block_id}
end note

note right of CacheLayer
    Redis cache layer is used for:
    1. Accelerating metadata access
    2. Reducing NameNode load
    3. Improving read performance for hot data
end note

' Relationships
FileMetadata "1" -- "0..*" BlockMetadata
BlockMetadata "0..*" -- "1..*" DataNodeInfo
DataNodeInfo "1" -- "0..*" BlockReport
BlockMetadata "1" -- "1" DataBlocks
EditLog "1..*" -- "0..1" FSImage
FileMetadata "1" -- "0..*" EditLog
BlockMetadata "1" -- "0..*" EditLog
RedisCache "0..*" -- "1" FileMetadata
RedisCache "0..*" -- "1" BlockMetadata

' Layout
NameNode -[hidden]right- DataNode
NameNode -[hidden]down- NameNodeStorage
NameNodeStorage -[hidden]right- CacheLayer

note as PerformanceNote
Performance optimization and scalability considerations:
1. Use Redis cache to reduce NameNode load
2. Improve availability and read performance through data block replication
3. Optimize data placement using rack awareness strategy
4. Implement Secondary NameNode for faster failure recovery
5. Consider HDFS Federation for horizontal scaling
end note
PerformanceNote -[hidden]right- CacheLayer
@enduml
