@startuml
!define RECTANGLE class
!define DATABASE database
!define CLOUD cloud

skinparam backgroundColor #E0E0E0
skinparam handwritten false
skinparam monochrome false
skinparam shadowing false
skinparam defaultFontName Arial
skinparam defaultFontSize 12
skinparam arrowColor #2C3E50
skinparam arrowThickness 1.5

skinparam rectangle {
  BackgroundColor #3498DB
  BorderColor #2980B9
  FontColor #ECF0F1
  BorderThickness 2
  Shadowing false
}

skinparam database {
  BackgroundColor #E74C3C
  BorderColor #C0392B
  FontColor #ECF0F1
}

skinparam cloud {
  BackgroundColor #95A5A6
  BorderColor #7F8C8D
  FontColor #ECF0F1
}

skinparam package {
  BackgroundColor #9B59B6
  BorderColor #8E44AD
  FontColor #ECF0F1
}

title Telegram-like System Architecture with Read/Write Splitting and Sharding

rectangle "Client Side" {
  [Sender's Client]
  [Receiver's Client]
}

rectangle "Frontend Services" {
  [Load Balancer]
  [Service Instance]
}

rectangle "Backend Services" {
  package "Authorization Service" {
    [Authorization & Permissions]
  }
  
  package "Message System" {
    [Kafka (Message Queue)]
    [Kafka (Pub/Sub Model)]
    [Message Worker]
  }
  
  package "Notification Service" {
    [Notification Handler]
    [Push Notification Service]
  }
}

database "Database System" {
  package "MongoDB Cluster" {
    database "Config Servers"
    package "Shard" {
      database "Primary"
      database "Secondary 1"
      database "Secondary 2"
    }
    [MongoDB Router (mongos)]
  }
  database "Redis Cache"
}

cloud "Monitoring & Logging" {
  [Monitoring]
  [Logging]
}

' Message Flow
[Sender's Client] --> [Load Balancer]: 1. Send Message
[Load Balancer] --> [Service Instance]
[Service Instance] --> [Authorization & Permissions]: 2. Check Permission
[Authorization & Permissions] --> [Kafka (Message Queue)]: 3. Authorized Message
[Kafka (Message Queue)] --> [Message Worker]: 4. Process Message
[Message Worker] --> [MongoDB Router (mongos)]: 5. Store Message
[MongoDB Router (mongos)] --> [Primary]: 6. Write to Shard
[Message Worker] --> [Redis Cache]: 7. Update Cache
[Message Worker] --> [Kafka (Pub/Sub Model)]: 8. Publish Message Event
[Kafka (Pub/Sub Model)] --> [Notification Handler]: 9. Trigger Notification
[Notification Handler] --> [Push Notification Service]: 10. Send Push Notification
[Push Notification Service] --> [Receiver's Client]: 11. Deliver Notification

' Read Message Flow
[Receiver's Client] --> [Load Balancer]: 12. Request to Read Message
[Service Instance] --> [Redis Cache]: 13. Check Cache
[Redis Cache] --> [Service Instance]: 14. Return Cached Message (if available)
[Service Instance] -[#FF5733,thickness=2]-> [MongoDB Router (mongos)]: 15. Fetch Message (if not in cache)
[MongoDB Router (mongos)] --> [Secondary 1]: 16. Read from Shard
[MongoDB Router (mongos)] -[#33FF57,thickness=2]-> [Service Instance]: 17. Return Message
[Service Instance] --> [Receiver's Client]: 18. Deliver Message

' Replication
[Primary] --> [Secondary 1]: Replicate
[Primary] --> [Secondary 2]: Replicate

' Config Servers
[Config Servers] --> [MongoDB Router (mongos)]: Provide Cluster Metadata

' Logging and Monitoring
[Service Instance] --> [Monitoring & Logging]: Log Events

@enduml
