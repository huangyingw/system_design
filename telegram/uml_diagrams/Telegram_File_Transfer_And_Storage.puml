@startuml Telegram_File_Transfer_And_Storage_Optimized

' Set theme and styling
skinparam backgroundColor #E6E6FA
skinparam handwritten false
skinparam monochrome false
skinparam packageStyle rectangle
skinparam defaultFontName Arial
skinparam defaultFontSize 28
skinparam ArrowFontSize 24
skinparam NoteFontSize 26
skinparam roundcorner 10
skinparam shadowing false
skinparam nodesep 60
skinparam ranksep 60

' Color scheme
skinparam rectangle {
    BackgroundColor #F0F8FF
    BorderColor #4682B4
    FontColor #000080
}
skinparam database {
    BackgroundColor #F0FFFF
    BorderColor #20B2AA
    FontColor #008080
}
skinparam cloud {
    BackgroundColor #F0F8FF
    BorderColor #6495ED
    FontColor #4169E1
}
skinparam queue {
    BackgroundColor #FFF0F5
    BorderColor #DB7093
    FontColor #C71585
}
skinparam note {
    BackgroundColor #FFFAF0
    BorderColor #DEB887
    FontColor #8B4513
}
skinparam arrow {
    Color #4682B4
    FontColor #000080
}

' Define components
rectangle "Client Apps" as CA {
    [Mobile App]
    [Desktop Client]
    [Web Client]
}

cloud "Global LB" as GLB {
    [GeoDNS]
}

rectangle "Regional LBs" as RLB {
    [LB - US]
    [LB - EU]
    [LB - Asia]
}

rectangle "File Transfer\nService Cluster" as FTSC {
    [Chunk Manager]
    [Metadata Handler]
    [Encryption Service]
    [Deduplication]
}

database "Metadata DB" as MDB {
    [Cassandra]
}

note right of MDB
    <b>Sharding Key: file_id</b>
    --
    1. Efficient query by file ID
    2. Same shard for file metadata
    3. Support file-level operations
end note

database "Object Storage" as OS {
    [S3-compatible]
}

note right of OS
    <b>Sharding Key: chunk_id</b>
    --
    1. Independent access, high parallelism
    2. Support chunking and resumable transfers
    3. Even distribution, avoid hotspots
    4. Easy horizontal scaling
end note

cloud "CDN" as CDN {
    [Edge Servers]
    [Caching Servers]
}

queue "File Processing\nQueue" as FPQ {
    [Kafka]
}

database "Cache Layer" as CL {
    [Redis]
}

note right of CL
    <b>Key Design:</b>
    1. File metadata: file:{id}:meta
       Hash(name,size,type,time)
    2. File chunk list: file:{id}:chunks
       Set(chunk_id1, chunk_id2, ...)
    3. Chunk metadata: chunk:{id}:meta
       Hash(size,checksum,location)
    4. User recent files: user:{id}:recent
       SortedSet(file_id, timestamp)
    5. File access count: file:{id}:access
       String(count)
    6. Upload status: file:{id}:upload
       Hash(total,uploaded,status)
    --
    <b>Expiration Strategy:</b>
    - Metadata/chunks: LRU, 1h
    - Recent files: 7d
    - Access count: 30d
    - Upload status: 15m after completion
end note

rectangle "File Processing\nWorkers" as FPW {
    [Thumbnail Gen]
    [Video Transcoder]
    [Virus Scanner]
}

' Define relationships
CA <--> GLB : HTTPS
GLB --> RLB : Route
RLB --> FTSC : Distribute
FTSC <--> MDB : CRUD
FTSC <--> OS : Store/Retrieve
FTSC --> CDN : Distribute
CDN --> CA : Serve
FTSC --> FPQ : Enqueue
FPQ --> FPW : Process
FTSC <--> CL : Cache

note "file_id and chunk_id relationship:\n1. One file_id maps to multiple chunk_ids\n2. Metadata DB stores the mapping\n3. Upload: file_id first, then chunk_ids\n4. Download: query all chunk_ids by file_id\n5. chunk_id format: file_id + sequence number\n6. Support large file chunked transfer" as Rel
Rel .. MDB
Rel .. OS

@enduml
