@startuml ' ==================== Metadata ====================
' ==================== Enhanced Metadata ====================
' === 基础分类 ===
' @category: distributed-systems
' @subcategory: message-queue
' @tags: #kafka, #message-queue, #event-streaming, #distributed-systems
' @description: Telegram Message Prioritization And Delivery System With Load Balancing
'
' === 应用场景 ===
' @application: Telegram
' @industry: General, Enterprise
' @use-cases: System Monitoring, Log Aggregation
' @business-value: Improved scalability, High availability, Better performance, Cost efficiency
'
' === 技术栈 ===
' @tech-stack: Kafka, ZooKeeper, Redis, MongoDB
' @programming-languages: Go, Scala
' @frameworks: Framework-agnostic
' @protocols: HTTP/REST, TCP
' @apis: REST API
'
' === 架构模式 ===
' @pattern: Event-Driven Architecture, Circuit Breaker
' @design-pattern: Observer, Producer-Consumer, Repository, Factory
' @data-flow: Client → Gateway → Service → Database
' @communication-style: Asynchronous, Event-driven
'
' === 分布式特性 ===
' @cap-focus: AP (Availability + Partition Tolerance)
' @consistency-model: Eventual Consistency (configurable)
' @consensus-algorithm: Raft, Leader Election
' @partition-strategy: Hash-based, Key-based, Custom partitioning
'
' === 性能与扩展 ===
' @scale: Medium to Large (1K-100K users, 100-10K QPS)
' @scalability: Horizontal scaling, Auto-scaling, Load balancing
' @performance-metrics: Throughput: 1M+ msg/s, Latency: <10ms p99
' @optimization-techniques: Caching, Sharding/Partitioning
' @throughput: Very High (1M+ messages/second)
' @latency: Low (<10ms p99)
'
' === 可靠性 ===
' @reliability: Replication, Redundancy, Health checks, Automatic recovery
' @fault-tolerance: Replication, Circuit breaker, Retry mechanism
' @disaster-recovery: Multi-datacenter replication, Backup strategies, RPO/RTO management
' @availability: 99.99% (4 nines)
' @data-durability: 99.999999999% (11 nines) with proper replication
'
' === 安全性 ===
' @security-features: Authentication, Authorization
' @authentication: OAuth 2.0, JWT, API Keys, SASL
' @authorization: RBAC (Role-Based Access Control), ACLs, Policy-based
' @encryption: TLS (in-transit), Optional encryption at rest
' @compliance: GDPR-ready, SOC2, HIPAA-compatible, PCI-DSS
'
' === 存储 ===
' @storage-type: Log Storage
' @database-type: NoSQL, In-Memory
' @caching-strategy: Cache-aside, Write-through, TTL-based expiration
' @data-persistence: Disk-based with WAL, Configurable durability, Snapshot backups
'
' === 监控运维 ===
' @monitoring: Prometheus, Grafana, Custom metrics, Health checks
' @logging: Centralized logging (ELK/Splunk), Structured logs, Log aggregation
' @alerting: Prometheus Alertmanager, PagerDuty, Custom alerts, SLA monitoring
' @observability: Metrics (RED/USE), Logs, Distributed tracing (Jaeger/Zipkin)
'
' === 部署 ===
' @deployment: Kubernetes, Docker, Cloud-native, Blue-Green deployment
' @infrastructure: Cloud, On-premise, Hybrid, Multi-cloud
' @cloud-provider: AWS, Azure, GCP, Cloud-agnostic
' @containerization: Docker-ready, Container-friendly
'
' === 成本 ===
' @cost-factors: Compute instances, Storage costs, Network bandwidth, Licensing
' @cost-optimization: Reserved instances, Auto-scaling, Storage tiering, Compression, Resource right-sizing
' @resource-usage: CPU: Medium-High, Memory: Medium-High, Disk I/O: High, Network: Medium
'
' === 复杂度 ===
' @complexity: Medium
' @implementation-difficulty: Medium
' @maintenance-complexity: Medium
'
' === 学习 ===
' @difficulty-level: Intermediate
' @learning-value: Medium to High (practical system design)
' @prerequisites: Message queues, Pub-Sub pattern, Database fundamentals, SQL/NoSQL
' @related-concepts: CAP theorem, Replication strategies, Data partitioning, Event sourcing, CQRS, Caching strategies, Cache invalidation
'
' === 数据特征 ===
' @data-volume: Medium to Large (GBs to TBs)
' @data-velocity: Near real-time, Mixed batch and streaming
' @data-variety: Structured, Semi-structured (JSON, Avro)
' @data-model: Document, Key-Value, Relational, Time-series
'
' === 集成 ===
' @integration-points: REST APIs, Message queues, Database connectors, Webhooks
' @third-party-services: Cloud storage, CDN, Payment processors, Analytics services
' @external-dependencies: Minimal external dependencies
'
' === 测试 ===
' @testing-strategy: Unit tests, Integration tests, Load tests, Chaos engineering
' @quality-assurance: CI/CD pipelines, Code review, Static analysis, Performance testing
'
' === 版本 ===
' @version: 1.0 (current design)
' @maturity: Production-ready, Battle-tested
' @evolution-stage: Active development, Continuous improvement
'
' === 关联 ===
' @related-files: See other architecture diagrams in the same directory
' @alternatives: Multiple implementation approaches available
' @comparison-with: Traditional monolithic vs distributed approaches
'
' === 实战 ===
' @real-world-examples: LinkedIn, Netflix, Uber, Airbnb
' @companies-using: LinkedIn, Netflix, Uber, Airbnb
' @production-readiness: Production-ready, Battle-tested at scale, Enterprise-grade
' ==================================================


!pragma layout dot
allowmixing

skinparam backgroundColor #FAFAFA
skinparam defaultFontName Arial
skinparam defaultFontSize 21
skinparam arrowThickness 1.5
skinparam noteFontSize 21 

title Telegram-like System Architecture with Read/Write Splitting and Sharding

rectangle "Client Side" as ClientSide #E0F7FA {
  component "Sender's Client" as SenderClient #4DD0E1
  component "Receiver's Client" as ReceiverClient #4DD0E1
}

rectangle "Frontend Services" as FrontendServices #FFF3E0 {
  component "Load Balancer" as LoadBalancer #FFB74D
  component "Service Instance" as ServiceInstance #FFB74D
}

rectangle "Backend Services" as BackendServices #E8F5E9 {
  rectangle "Authorization Service" as AuthService #A5D6A7 {
    component "Authorization & Permissions" as AuthPermissions #81C784
  }
  
  rectangle "Message System" as MessageSystem #FFCDD2 {
    component "Kafka (Message Queue)" as KafkaQueue #EF9A9A
    component "Kafka (Pub/Sub Model)" as KafkaPubSub #EF9A9A
    component "Message Worker" as MessageWorker #EF9A9A
  }
  
  rectangle "Notification Service" as NotificationService #B3E5FC {
    component "Notification Handler" as NotificationHandler #4FC3F7
    component "Push Notification Service" as PushNotificationService #4FC3F7
  }
}

rectangle "Database System" as DatabaseSystem #E1BEE7 {
  rectangle "MongoDB Cluster" as MongoDBCluster #D1C4E9 {
    component "Config Servers" as ConfigServers #B39DDB {
      component "Metadata" as Metadata #9575CD
    }
    rectangle "Shard" as Shard #D1C4E9 {
      component "Primary" as Primary #9575CD {
        component "Write Operations" as WriteOps #7E57C2
      }
      component "Secondary 1" as Secondary1 #9575CD {
        component "Read Operations" as ReadOps1 #7E57C2
      }
      component "Secondary 2" as Secondary2 #9575CD {
        component "Read Operations" as ReadOps2 #7E57C2
      }
    }
    component "MongoDB Router (mongos)" as MongoRouter #B39DDB
  }
  component "Redis Cache" as RedisCache #F8BBD0 {
    component "Key-Value Store" as KeyValueStore #F48FB1
  }
}

rectangle "Monitoring & Logging" as MonitoringLogging #CFD8DC {
  component "Monitoring" as Monitoring #B0BEC5
  component "Logging" as Logging #B0BEC5
}

' 消息流
SenderClient -[#1ABC9C,thickness=2]-> LoadBalancer: <back:#FFFFFF><color:#1ABC9C>1. Send Message</color></back>
LoadBalancer -[#1ABC9C,thickness=2]-> ServiceInstance
ServiceInstance -[#1ABC9C,thickness=2]-> AuthPermissions: <back:#FFFFFF><color:#1ABC9C>2. Check Permission</color></back>
AuthPermissions -[#1ABC9C,thickness=2]-> KafkaQueue: <back:#FFFFFF><color:#1ABC9C>3. Authorized Message</color></back>
KafkaQueue -[#1ABC9C,thickness=2]-> MessageWorker: <back:#FFFFFF><color:#1ABC9C>4. Process Message</color></back>
MessageWorker -[#1ABC9C,thickness=2]-> MongoRouter: <back:#FFFFFF><color:#1ABC9C>5. Store Message</color></back>
MongoRouter -[#1ABC9C,thickness=2]-> Primary: <back:#FFFFFF><color:#1ABC9C>6. Write to Shard</color></back>
MessageWorker -[#1ABC9C,thickness=2]-> RedisCache: <back:#FFFFFF><color:#1ABC9C>7. Update Cache</color></back>
MessageWorker -[#1ABC9C,thickness=2]-> KafkaPubSub: <back:#FFFFFF><color:#1ABC9C>8. Publish Message Event</color></back>
KafkaPubSub -[#1ABC9C,thickness=2]-> NotificationHandler: <back:#FFFFFF><color:#1ABC9C>9. Trigger Notification</color></back>
NotificationHandler -[#1ABC9C,thickness=2]-> PushNotificationService: <back:#FFFFFF><color:#1ABC9C>10. Send Push Notification</color></back>
PushNotificationService -[#1ABC9C,thickness=2]-> ReceiverClient: <back:#FFFFFF><color:#1ABC9C>11. Deliver Notification</color></back>

' 读取消息流
ReceiverClient -[#F39C12,thickness=2]-> LoadBalancer: <back:#FFFFFF><color:#F39C12>12. Request to Read Message</color></back>
ServiceInstance -[#F39C12,thickness=2]-> RedisCache: <back:#FFFFFF><color:#F39C12>13. Check Cache</color></back>
RedisCache -[#F39C12,thickness=2]-> ServiceInstance: <back:#FFFFFF><color:#F39C12>14. Return Cached Message (if available)</color></back>
ServiceInstance -[#F39C12,thickness=2]-> MongoRouter: <back:#FFFFFF><color:#F39C12>15. Fetch Message (if not in cache)</color></back>
MongoRouter -[#F39C12,thickness=2]-> Secondary1: <back:#FFFFFF><color:#F39C12>16. Read from Shard</color></back>
MongoRouter -[#F39C12,thickness=2]-> ServiceInstance: <back:#FFFFFF><color:#F39C12>17. Return Message</color></back>
ServiceInstance -[#F39C12,thickness=2]-> ReceiverClient: <back:#FFFFFF><color:#F39C12>18. Deliver Message</color></back>

' 复制
Primary -[#8E44AD,thickness=2]-> Secondary1: <back:#FFFFFF><color:#8E44AD>Replicate</color></back>
Primary -[#8E44AD,thickness=2]-> Secondary2: <back:#FFFFFF><color:#8E44AD>Replicate</color></back>

' 配置服务器
ConfigServers -[#27AE60,thickness=2]-> MongoRouter: <back:#FFFFFF><color:#27AE60>Provide Cluster Metadata</color></back>

' 日志和监控
ServiceInstance -[#95A5A6,thickness=2]-> MonitoringLogging: <back:#FFFFFF><color:#95A5A6>Log Events</color></back>

note top of MongoRouter
  Sharding Key: user_id
  Improves query performance
  and scalability
end note

note right of RedisCache
  Key: user_id:message_id
  Reduces database load
  and improves read speed
end note

note bottom of KafkaQueue
  Ensures reliable message
  delivery and scalability
end note

note bottom of LoadBalancer
  Potential bottleneck
  Consider using DNS round-robin
  or hardware load balancing for
  higher throughput
end note

note right of AuthPermissions
  Cache frequently used permissions
  to reduce latency and database load
end note

note bottom of MessageWorker
  Optimize for parallel processing
  Consider using a worker pool
  to handle high message volumes
end note

note top of MongoDBCluster
  Monitor replication lag
  Implement read preferences
  based on consistency requirements
end note

note bottom of PushNotificationService
  Implement retry mechanism and
  circuit breaker for reliability
end note

@enduml
